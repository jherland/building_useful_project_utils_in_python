<!DOCTYPE html>
<html>
  <head>
    <title>Building useful project utils in Python</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      a {
        color: #F92672;
        text-decoration: none;
      }
      li {
        padding: 2px;
      }

      .remark-code, .remark-inline-code {
        font-family: 'Ubuntu Mono';
        background: #e8e8e8;
        padding: 2px 5px;
      }

      .inverse {
        background: #272822;
        color: #777872;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }

      .column:first-of-type { float: left; }
      .column { float: right; }
      .split-50 .column { width: 48%; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle, inverse

# Building useful project utils in Python

## From spaghetti shell scripts to presentable Python

Johan Herland<br />
<a href="https://twitter.com/jherland">@jherland</a><br />
&lt;<a href="mailto:jherland@cisco.com">jherland@cisco.com</a>&gt;<br />
&lt;<a href="mailto:johan@herland.net">johan@herland.net</a>&gt;

???

Who am I?

- Software Engineer at Cisco Systems Norway, developing videoconferencing systems
- Work on:
    - Some applicaton-level programming
    - More underlying platform work
    - Version control, build systems, developer tools

---

# Prerequisites

- Basic familiarity with Unix shell scripting (<code>bash</code>)

- Some familiarity with <code>python3</code> (<code>python2</code> also works, but YMMV)

---

# Outline

- Motivation
    - What scripts are we talking about?
    - Shell scripts! What are they good for?
    - Why is Python better?
- Shell &rarr; Python &mdash; Tips + Techniques
    - Organizing your scripts
    - Command-line interfaces in Python
    - Running other programs from Python
    - Manipulating the filesystem from Python
    - Writing unit tests in Python
    - Other useful Python modules for system utils?
    - Other useful stuff?
- Case study &mdash; <code>binst</code>
- Summary
- Q &amp; A

---

class: center, middle, inverse

# Motivation

---

class: split-50

## What scripts are we talking about?

"The glue that holds your project together"

.column[

### Developer tools
- Wrappers for more complex commands
- Workflow helpers

### Build-time

- Small + simple build systems
- Build system helpers, plug-ins
- Code generators

]
.column[

### Packaging, deployment, release, etc.

- Signing images
- Publishing assets

### In production

- Embedded targets
- Inside deployed containers

]

---

class: split-50

## Shell scripts! What are they good for?

.column[

### Pros

- Short and simple stuff
- Straightforward logic
- No data structures

]
.column[

### Cons

- Scripts grow, in length and complexity
- Complex logic
- Data structures
- Configurability
- Reusability
- Safety!

]

---

## Why is Python better?

### Showdown! Shell vs. Python

---

class: split-50

## Why is Python better? &mdash; Syntax

.column[

### Shell

- Reasonably easy to become productive
- Similar to command-line; skills are transferable
- Complexity &rarr; write-only
- Trivial (and necessary) to run other programs
- Many pitfalls, hard to become **safe**
- Many online resources/examples
- **Common practice** != **Best practice**!

```bash
filename="My favourite quotations.txt"
touch $filename
```

]
.column[

### Python

- Simple and beginner-friendly syntax
- Considered one of the more readable languages
- Not as trivial to run other programs
- Fewer pitfalls than shell.
- Lots of literature and resources.
- Harder to come across "dangerous" examples

]

---

class: split-50

## Why is Python better? &mdash; Data structures and types

.column[

### Shell

- Everything is a string
- Whitespace in values often cause problems, and must be handled carefully
- Some support for integer arithmetic
- Some support for arrays

<blockquote><small>
<a href="http://tldp.org/LDP/abs/html/untyped.html">Advanced Bash-Scripting Guide</a> says:<br />
&laquo;Unlike many other programming languages, Bash does not segregate its variables by "type." Essentially, Bash variables are character strings, but, depending on context, Bash permits arithmetic operations and comparisons on variables. The determining factor is whether the value of a variable contains only digits.&raquo;
</small></blockquote>

]
.column[

### Python

- Dynamically (but strongly) typed
- Built-in types:
    - Numerics — <code>int</code>, <code>float</code>, <code>complex</code>
    - Sequences — <code>list</code>, <code>tuple</code>, <code>range</code>
        - Text and binary data — <code>str</code>, <code>bytes</code>, &hellip;
        - Sets — <code>set</code>, &hellip;
    - Mappings — <code>dict</code>
    - Others:
        - Modules
        - Classes and Class instances
        - Functions and Methods
        - Iterators and Generators
        - Exceptions
        - etc.

]

---

class: split-50

## Why is Python better? &mdash; Modularity

.column[

### Shell

A file is **either** intended for immediate usage (maybe with purely-local function) **or** a bag of functions reusable by sourcing.

]
.column[

### Python

Modules with <code>\_\_main\_\_</code> guards allows **both** for importability, and for immediate usage!

]

---

class: split-50

## Why is Python better? &mdash; Modularity, cont.

.column[

<code>foo.sh</code>:
```bash
#!/bin/sh

echo "This is always run"

foo() {
    echo "This is foo"
}
```

<code>bar.sh</code>:
```bash
#!/bin/sh

source foo.sh

foo()
```

]
.column[

<code>foo.py</code>:
```python
#!/usr/bin/env python3

print("This is always run")

def foo():
    print('This is foo')

if __name__ == '__main__':
    print("Not run when this file is imported")
```

<code>bar.py</code>:
```python
#!/usr/bin/env python3

import foo

foo.foo()
```

]

---

class: split-50

## Why is Python better? &mdash; Tools &amp; Libraries

.column[

### Shell

- Language itself is fairly minimal
- Use system binaries from Unix ecosystem to do heavy lifting

]
.column[

### Python

- Very rich stdlib &mdash; can do most things "within" the language
- Use <code>subprocess</code> module to call out to other binaries

]

---

class: center, middle, inverse

# Shell &rarr; Python

## Tips + Techniques

---

## Organizing your scripts

- Start by replicating your shell script in Python
    - one statement after another, no structure, everything is run from top to bottom
- Introduce functions
    - Also common pattern in shell scripts
- Introduce the __main__ guard
    - The fundamental trick that makes your script import-able from other Python scripts
- Introduce main()
    - Not a huge change, but:
    - follows common conventions
    - Makes it possible for another Python script to import this module, and then run it as if it was the __main__ script.
- Split reusable functionality into separate/stand-alone modules
- Add unit tests to verify API + functionality of separate/stand-alone modules

---

## Command-line interfaces in Python

- argparse
- Unix conventions:
    - non-zero exit code on failure, otherwise exit 0
    - use stdin/stdout for default input/output
    - log errors to stderr (talk about <code>logging</code>?)

---

## Running other programs from Python

- <code>subprocess</code>

---

## Manipulating the filesystem from Python

- <code>pathlib</code>
- <code>shutil</code>?
- <code>os</code>?

---

## Writing unit tests in Python

- <code>doctest</code>
- <code>unittest</code>
- <code>py.test</code> (not in stdlib)

---

## Other useful Python modules for system utils?

---

## Other useful stuff?

- Simplify error handling:
    - Allowing exceptions to terminate program
    - Usefulness of tracebacks

---

class: center, middle, inverse

# Case study

## <tt>binst</tt>

- build/test cycle:
    - Run build to produce .pkg
    - Run binst to install .pkg onto device
        - Pushes .pkg onto device and triggers install + reboot
        - Useful workflow for developers

- Show overview of binst
    - identify larger sections
        - command-line handling
        - data structures
        - core logic

- Problems
    - Complex shell script
    - binst upgrades are different from in-the-field upgrades:
        - Codec is told where to find upgrade and _pulls_ it from there.
    - New requirement: Systems/composite devices!

- Systems/composite devices!
    - Codec plus peripherals
        - Must run same/compatible versions
    - One .pkg is not enough, also need .pkg for peripherals
    - Introduce .loads files
        - Tells system where to find .pkgs
        - System pulls the .pkgs needed to upgrade all devices
        - Same mechanism as upgrades in the field
    - Changes to dev workflow:
        - one or more build commands
        - single binst to update codec + peripherals:

- Required changes to binst:
    - Prepare directory with .loads file and associated .pkgs
    - Serve .loads file to system, and wait for .pkgs to be pulled.
    - (Fall-back to old push-method remains for older/simpler systems)

- How to get there:
    - Rewrite existing binst from bash to python
    - Refactor into smaller modules, ease readability and maintainability
    - Start adding new features
        - Generating .loads files
        - Knowledge of which peripheral .pkgs may be needed for what targets.
        - HTTP server to server directory with .loads files and .pkg files

- Techniques used during rewrite:
    - argparse
    - dictionaries!
    - subprocess

(- Adding new features:
    - http.server
)

---

# Summary

- What have we learned?
- Reusable component **and** user-friendly command-line
- Reusable module that runs unit tests when invoked from command line.

---

class: center, middle, inverse

# Thanks!

## Questions?

Johan Herland<br />
<a href="https://twitter.com/jherland">@jherland</a><br />
&lt;<a href="mailto:jherland@cisco.com">jherland@cisco.com</a>&gt;<br />
&lt;<a href="mailto:johan@herland.net">johan@herland.net</a>&gt;

<small>Slideshow created with [remark](http://gnab.github.com/remark).</small>

    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        ratio: "16:9"
      });
    </script>
  </body>
</html>
